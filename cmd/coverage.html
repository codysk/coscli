
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">coscli/cmd/abort.go (100.0%)</option>
				
				<option value="file1">coscli/cmd/bucket_tagging.go (100.0%)</option>
				
				<option value="file2">coscli/cmd/config.go (100.0%)</option>
				
				<option value="file3">coscli/cmd/config_add.go (97.6%)</option>
				
				<option value="file4">coscli/cmd/config_delete.go (100.0%)</option>
				
				<option value="file5">coscli/cmd/config_init.go (7.4%)</option>
				
				<option value="file6">coscli/cmd/config_set.go (98.5%)</option>
				
				<option value="file7">coscli/cmd/config_show.go (100.0%)</option>
				
				<option value="file8">coscli/cmd/cp.go (98.5%)</option>
				
				<option value="file9">coscli/cmd/du.go (100.0%)</option>
				
				<option value="file10">coscli/cmd/hash.go (95.3%)</option>
				
				<option value="file11">coscli/cmd/ls.go (100.0%)</option>
				
				<option value="file12">coscli/cmd/lsparts.go (100.0%)</option>
				
				<option value="file13">coscli/cmd/mb.go (100.0%)</option>
				
				<option value="file14">coscli/cmd/mv.go (82.6%)</option>
				
				<option value="file15">coscli/cmd/rb.go (100.0%)</option>
				
				<option value="file16">coscli/cmd/restore.go (97.6%)</option>
				
				<option value="file17">coscli/cmd/rm.go (87.0%)</option>
				
				<option value="file18">coscli/cmd/root.go (55.1%)</option>
				
				<option value="file19">coscli/cmd/signurl.go (100.0%)</option>
				
				<option value="file20">coscli/cmd/sync.go (97.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "context"
        "coscli/util"

        logger "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
)

var abortCmd = &amp;cobra.Command{
        Use:   "abort",
        Short: "Abort parts",
        Long: `Abort parts

Format:
  ./coscli abort cos://&lt;bucket-name&gt;[/&lt;prefix&gt;] [flags]

Example:
  ./coscli abort cos://examplebucket/test/`,
        Args: cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                include, _ := cmd.Flags().GetString("include")
                exclude, _ := cmd.Flags().GetString("exclude")

                err := abortParts(args[0], include, exclude)
                return err
        }</span>,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(abortCmd)

        abortCmd.Flags().String("include", "", "List files that meet the specified criteria")
        abortCmd.Flags().String("exclude", "", "Exclude files that meet the specified criteria")
}</span>

func abortParts(arg string, include string, exclude string) error <span class="cov8" title="1">{
        bucketName, cosPath := util.ParsePath(arg)
        c, err := util.NewClient(&amp;config, &amp;param, bucketName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">uploads, err := util.GetUploadsListRecursive(c, cosPath, 0, include, exclude)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">successCnt, failCnt := 0, 0
        for _, u := range uploads </span><span class="cov8" title="1">{
                _, err := c.Object.AbortMultipartUpload(context.Background(), u.Key, u.UploadID)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Infoln("Abort fail!    UploadID:", u.UploadID, "Key:", u.Key)
                        failCnt++
                }</span> else<span class="cov8" title="1"> {
                        logger.Infoln("Abort success! UploadID:", u.UploadID, "Key:", u.Key)
                        successCnt++
                }</span>
        }
        <span class="cov8" title="1">logger.Infoln("Total:", len(uploads), ",", successCnt, "Success,", failCnt, "Fail")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "context"
        "coscli/util"
        "fmt"
        "os"
        "strings"

        "github.com/olekukonko/tablewriter"
        "github.com/spf13/cobra"
        "github.com/tencentyun/cos-go-sdk-v5"
)

var bucketTaggingCmd = &amp;cobra.Command{
        Use:   "bucket-tagging",
        Short: "Modify bucket tagging",
        Long: `Modify bucket tagging

Format:
        ./coscli bucket-tagging --method [method] cos://&lt;bucket-name&gt; [tag_key]#[tag_value]

Example:
        ./coscli bucket-tagging --method put cos://examplebucket tag1#test1 tag2#test2
        ./coscli bucket-tagging --method get cos://examplebucket
        ./coscli bucket-tagging --method delete cos://examplebucket`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                method, _ := cmd.Flags().GetString("method")

                var err error
                if method == "put" </span><span class="cov8" title="1">{
                        if len(args) &lt; 2 </span><span class="cov8" title="1">{
                                return fmt.Errorf("not enough arguments in call to put bucket tagging")
                        }</span>
                        <span class="cov8" title="1">err = putBucketTagging(args[0], args[1:])</span>
                }

                <span class="cov8" title="1">if method == "get" </span><span class="cov8" title="1">{
                        if len(args) &lt; 1 </span><span class="cov8" title="1">{
                                return fmt.Errorf("not enough arguments in call to get bucket tagging")
                        }</span>
                        <span class="cov8" title="1">err = getBucketTagging(args[0])</span>
                }

                <span class="cov8" title="1">if method == "delete" </span><span class="cov8" title="1">{
                        if len(args) &lt; 1 </span><span class="cov8" title="1">{
                                return fmt.Errorf("not enough arguments in call to delete bucket tagging")
                        }</span>
                        <span class="cov8" title="1">err = deleteBucketTagging(args[0])</span>
                }

                <span class="cov8" title="1">return err</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(bucketTaggingCmd)
        bucketTaggingCmd.Flags().String("method", "", "put/get/delete")
}</span>

func putBucketTagging(cosPath string, tags []string) error <span class="cov8" title="1">{
        bucketName, _ := util.ParsePath(cosPath)
        c, err := util.NewClient(&amp;config, &amp;param, bucketName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">tg := &amp;cos.BucketPutTaggingOptions{}
        for i := 0; i &lt; len(tags); i += 1 </span><span class="cov8" title="1">{
                tmp := strings.Split(tags[i], "#")
                if len(tmp) &gt;= 2 </span><span class="cov8" title="1">{
                        tg.TagSet = append(tg.TagSet, cos.BucketTaggingTag{Key: tmp[0], Value: tmp[1]})
                }</span> else<span class="cov8" title="1"> {
                        return fmt.Errorf("invalid tag")
                }</span>
        }

        <span class="cov8" title="1">_, err = c.Bucket.PutTagging(context.Background(), tg)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func getBucketTagging(cosPath string) error <span class="cov8" title="1">{
        bucketName, _ := util.ParsePath(cosPath)
        c, err := util.NewClient(&amp;config, &amp;param, bucketName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">v, _, err := c.Bucket.GetTagging(context.Background())
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">table := tablewriter.NewWriter(os.Stdout)
        table.SetHeader([]string{"Key", "Value"})
        for _, t := range v.TagSet </span><span class="cov8" title="1">{
                table.Append([]string{t.Key, t.Value})
        }</span>
        <span class="cov8" title="1">table.SetBorder(false)
        table.SetAlignment(tablewriter.ALIGN_RIGHT)
        table.Render()

        return nil</span>
}

func deleteBucketTagging(cosPath string) error <span class="cov8" title="1">{
        bucketName, _ := util.ParsePath(cosPath)
        c, err := util.NewClient(&amp;config, &amp;param, bucketName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">_, err = c.Bucket.DeleteTagging(context.Background())
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "github.com/spf13/cobra"
)

var configCmd = &amp;cobra.Command{
        Use:   "config",
        Short: "Init or edit config file",
        Long:  "Init or edit config file",
        Run: func(cmd *cobra.Command, args []string) <span class="cov8" title="1">{
                _ = cmd.Help()
        }</span>,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(configCmd)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/mitchellh/go-homedir"

        "coscli/util"

        logger "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var configAddCmd = &amp;cobra.Command{
        Use:   "add",
        Short: "Used to add a new bucket configuration",
        Long: `Used to add a new bucket configuration

Format:
  ./coscli config add -b &lt;bucket-name&gt; -e &lt;endpoint&gt; -a &lt;alias&gt; [-c &lt;config-file-path&gt;]

Example:
  ./coscli config add -b example-1234567890 -r ap-shanghai -a example`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                err := addBucketConfig(cmd)
                return err
        }</span>,
}

func init() <span class="cov8" title="1">{
        configCmd.AddCommand(configAddCmd)

        configAddCmd.Flags().StringP("bucket", "b", "", "Bucket name")
        configAddCmd.Flags().StringP("endpoint", "e", "", "Bucket endpoint")
        configAddCmd.Flags().StringP("region", "r", "", "Bucket region")
        configAddCmd.Flags().StringP("alias", "a", "", "Bucket alias")
        configAddCmd.Flags().BoolP("ofs", "o", false, "Bucket ofs")

        _ = configAddCmd.MarkFlagRequired("bucket")
        // _ = configAddCmd.MarkFlagRequired("endpoint")
}</span>

func addBucketConfig(cmd *cobra.Command) error <span class="cov8" title="1">{
        name, _ := cmd.Flags().GetString("bucket")
        endpoint, _ := cmd.Flags().GetString("endpoint")
        region, _ := cmd.Flags().GetString("region")
        alias, _ := cmd.Flags().GetString("alias")
        ofs, _ := cmd.Flags().GetBool("ofs")

        if alias == "" </span><span class="cov8" title="1">{
                alias = name
        }</span>
        <span class="cov8" title="1">bucket := util.Bucket{
                Name:     name,
                Endpoint: endpoint,
                Region:   region,
                Alias:    alias,
                Ofs:      ofs,
        }

        for _, b := range config.Buckets </span><span class="cov8" title="1">{
                if name == b.Name </span><span class="cov8" title="1">{
                        return fmt.Errorf("The bucket already exists, fail to add!")
                }</span> else<span class="cov8" title="1"> if alias == b.Name </span><span class="cov8" title="1">{
                        return fmt.Errorf("The alias cannot be the same as other bucket's name")
                }</span> else<span class="cov8" title="1"> if alias == b.Alias </span><span class="cov8" title="1">{
                        return fmt.Errorf("The alias already exists, fail to add!")
                }</span>
        }

        <span class="cov8" title="1">config.Buckets = append(config.Buckets, bucket)
        viper.Set("cos.buckets", config.Buckets)

        // 判断config文件是否存在。不存在则创建
        home, err := homedir.Dir()
        configFile := ""
        if cfgFile != "" </span><span class="cov8" title="1">{
                if cfgFile[0] == '~' </span><span class="cov0" title="0">{
                        configFile = home + cfgFile[1:]
                }</span> else<span class="cov8" title="1"> {
                        configFile = cfgFile
                }</span>
        } else<span class="cov8" title="1"> {
                configFile = home + "/.cos.yaml"
        }</span>
        <span class="cov8" title="1">_, err = os.Stat(configFile)
        if os.IsNotExist(err) || cfgFile != "" </span><span class="cov8" title="1">{
                if err := viper.WriteConfigAs(configFile); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                if err := viper.WriteConfigAs(viper.ConfigFileUsed()); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">logger.Infof("Add successfully! name: %s, endpoint: %s, alias: %s\n, ofs: %t\n", name, endpoint, alias, ofs)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package cmd

import (
        "coscli/util"
        "fmt"
        logger "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var configDeleteCmd = &amp;cobra.Command{
        Use:   "delete",
        Short: "Used to delete an existing bucket",
        Long: `Used to delete an existing bucket

Format:
  ./coscli config delete -a &lt;alias&gt; [-c &lt;config-file-path&gt;]

Example:
  ./coscli config delete -a example`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                err := deleteBucketConfig(cmd)
                return err
        }</span>,
}

func init() <span class="cov8" title="1">{
        configCmd.AddCommand(configDeleteCmd)

        configDeleteCmd.Flags().StringP("alias", "a", "", "Bucket alias")

        _ = configDeleteCmd.MarkFlagRequired("alias")
}</span>

func deleteBucketConfig(cmd *cobra.Command) error <span class="cov8" title="1">{
        alias, _ := cmd.Flags().GetString("alias")
        b, i, err := util.FindBucket(&amp;config, alias)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if i &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("Bucket not exist in config file!")
        }</span>
        <span class="cov8" title="1">config.Buckets = append(config.Buckets[:i], config.Buckets[i+1:]...)

        viper.Set("cos.buckets", config.Buckets)
        if err := viper.WriteConfigAs(viper.ConfigFileUsed()); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">logger.Infof("Delete successfully! name: %s, endpoint: %s, alias: %s", b.Name, b.Endpoint, b.Alias)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package cmd

import (
        "coscli/util"
        "fmt"
        "github.com/spf13/viper"

        homedir "github.com/mitchellh/go-homedir"
        "github.com/spf13/cobra"
)

var configInitCmd = &amp;cobra.Command{
        Use:   "init",
        Short: "Used to interactively generate the configuration file",
        Long: `Used to interactively generate the configuration file

Format:
  ./coscli config init [-c &lt;config-file-path&gt;]

Example:
  ./coscli config init`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                if cmdCnt &gt;= 1 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">err := initConfigFile(true)
                return err</span>
        },
}

func init() <span class="cov8" title="1">{
        configCmd.AddCommand(configInitCmd)
}</span>

// cfgFlag: 是否允许用户自定义配置文件的输出路径
func initConfigFile(cfgFlag bool) error <span class="cov0" title="0">{
        var (
                configFile string
                config     util.Config
                bucket     util.Bucket
        )
        home, _ := homedir.Dir()

        if cfgFlag </span><span class="cov0" title="0">{
                fmt.Println("Specify the path of the configuration file: (default:" + home + "/.cos.yaml)")
                _, _ = fmt.Scanf("%s\n", &amp;configFile)
        }</span>
        <span class="cov0" title="0">if configFile == "" </span><span class="cov0" title="0">{
                configFile = home + "/.cos.yaml"
        }</span>
        <span class="cov0" title="0">if configFile[0] == '~' </span><span class="cov0" title="0">{
                configFile = home + configFile[1:]
        }</span>
        <span class="cov0" title="0">fmt.Println("The path of the configuration file: " + configFile)

        fmt.Println("Input Your Mode:")
        _, _ = fmt.Scanf("%s\n", &amp;config.Base.Mode)

        if config.Base.Mode == "CvmRole" </span><span class="cov0" title="0">{
                fmt.Println("Input Your Cvm Role Name:")
                _, _ = fmt.Scanf("%s\n", &amp;config.Base.CvmRoleName)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Input Your Secret ID:")
                _, _ = fmt.Scanf("%s\n", &amp;config.Base.SecretID)
                fmt.Println("Input Your Secret Key:")
                _, _ = fmt.Scanf("%s\n", &amp;config.Base.SecretKey)
                fmt.Println("Input Your Session Token:")
                _, _ = fmt.Scanf("%s\n", &amp;config.Base.SessionToken)
        }</span>

        <span class="cov0" title="0">fmt.Println("Input Auto Switch Host:")
        _, _ = fmt.Scanf("%s\n", &amp;config.Base.CloseAutoSwitchHost)
        if len(config.Base.SessionToken) &lt; 3 </span><span class="cov0" title="0">{
                config.Base.SessionToken = ""
        }</span>
        <span class="cov0" title="0">config.Base.Protocol = "https"

        fmt.Println("Input Your Bucket's Name:")
        fmt.Println("Format: &lt;bucketname&gt;-&lt;appid&gt;，Example: example-1234567890")
        _, _ = fmt.Scanf("%s\n", &amp;bucket.Name)
        fmt.Println("Input Bucket's Endpoint:")
        fmt.Println("Format: cos.&lt;region&gt;.myqcloud.com，Example: cos.ap-beijing.myqcloud.com")
        _, _ = fmt.Scanf("%s\n", &amp;bucket.Endpoint)
        fmt.Println("Input Bucket's Alias: (Input nothing will use the original name)")
        _, _ = fmt.Scanf("%s\n", &amp;bucket.Alias)
        if bucket.Alias == "" </span><span class="cov0" title="0">{
                bucket.Alias = bucket.Name
        }</span>

        <span class="cov0" title="0">config.Buckets = append(config.Buckets, bucket)
        fmt.Println("You have configured the bucket:")
        for _, b := range config.Buckets </span><span class="cov0" title="0">{
                fmt.Printf("- Name: %s\tEndpoint: %s\tAlias: %s\n", b.Name, b.Endpoint, b.Alias)
        }</span>
        <span class="cov0" title="0">fmt.Printf("\nIf you want to configure more buckets, you can use the \"config add\" command later.\n")
        // 默认加密存储
        config.Base.SecretKey, _ = util.EncryptSecret(config.Base.SecretKey)
        config.Base.SecretID, _ = util.EncryptSecret(config.Base.SecretID)
        config.Base.SessionToken, _ = util.EncryptSecret(config.Base.SessionToken)

        viper.Set("cos", config)

        if err := viper.WriteConfigAs(configFile); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">fmt.Printf("\nThe configuration file is initialized successfully! \nYou can use \"./coscli config show [-c &lt;Config File Path&gt;]\" show the contents of the specified configuration file\n")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package cmd

import (
        "coscli/util"
        "fmt"
        "github.com/mitchellh/go-homedir"
        "os"

        logger "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var configSetCmd = &amp;cobra.Command{
        Use:   "set",
        Short: "Used to modify configuration items in the [base] group of the configuration file",
        Long: `Used to modify configuration items in the [base] group of the configuration file

Format:
  ./coscli config set [flags]

Example:
  ./coscli config set -t example-token`,
        Args: cobra.ExactArgs(0),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                err := setConfigItem(cmd)
                return err
        }</span>,
}

func init() <span class="cov8" title="1">{
        configCmd.AddCommand(configSetCmd)

        configSetCmd.Flags().StringP("secret_id", "", "", "Set secret id")
        configSetCmd.Flags().StringP("secret_key", "", "", "Set secret key")
        configSetCmd.Flags().StringP("session_token", "t", "", "Set session token")
        configSetCmd.Flags().StringP("mode", "", "", "Set mode")
        configSetCmd.Flags().StringP("cvm_role_name", "", "", "Set cvm role name")
        configSetCmd.Flags().StringP("close_auto_switch_host", "", "", "Close Auto Switch Host")
}</span>

func setConfigItem(cmd *cobra.Command) error <span class="cov8" title="1">{
        flag := false
        secretID, _ := cmd.Flags().GetString("secret_id")
        secretKey, _ := cmd.Flags().GetString("secret_key")
        sessionToken, _ := cmd.Flags().GetString("session_token")
        mode, _ := cmd.Flags().GetString("mode")
        cvmRoleName, _ := cmd.Flags().GetString("cvm_role_name")
        closeAutoSwitchHost, _ := cmd.Flags().GetString("close_auto_switch_host")
        if secretID != "" </span><span class="cov8" title="1">{
                flag = true
                if secretID == "@" </span><span class="cov8" title="1">{
                        config.Base.SecretID = ""
                }</span> else<span class="cov8" title="1"> {
                        config.Base.SecretID = secretID
                }</span>
        }
        <span class="cov8" title="1">if secretKey != "" </span><span class="cov8" title="1">{
                flag = true
                if secretKey == "@" </span><span class="cov8" title="1">{
                        config.Base.SecretKey = ""
                }</span> else<span class="cov8" title="1"> {
                        config.Base.SecretKey = secretKey
                }</span>
        }
        <span class="cov8" title="1">if sessionToken != "" </span><span class="cov8" title="1">{
                flag = true
                if sessionToken == "@" </span><span class="cov8" title="1">{
                        config.Base.SessionToken = ""
                }</span> else<span class="cov8" title="1"> {
                        config.Base.SessionToken = sessionToken
                }</span>
        }
        <span class="cov8" title="1">if mode != "" </span><span class="cov8" title="1">{
                flag = true
                if mode != "SecretKey" &amp;&amp; mode != "CvmRole" </span><span class="cov8" title="1">{
                        return fmt.Errorf("Please Enter Mode As SecretKey Or CvmRole!")
                }</span> else<span class="cov8" title="1"> {
                        config.Base.Mode = mode
                }</span>
        }
        <span class="cov8" title="1">if cvmRoleName != "" </span><span class="cov8" title="1">{
                flag = true
                if cvmRoleName == "@" </span><span class="cov8" title="1">{
                        config.Base.CvmRoleName = ""
                }</span> else<span class="cov8" title="1"> {
                        config.Base.CvmRoleName = cvmRoleName
                }</span>
        }

        <span class="cov8" title="1">if closeAutoSwitchHost != "" </span><span class="cov8" title="1">{
                flag = true
                if closeAutoSwitchHost == "@" </span><span class="cov8" title="1">{
                        config.Base.CloseAutoSwitchHost = ""
                }</span> else<span class="cov8" title="1"> {
                        config.Base.CloseAutoSwitchHost = closeAutoSwitchHost
                }</span>
        }

        <span class="cov8" title="1">if !flag </span><span class="cov8" title="1">{
                return fmt.Errorf("Enter at least one configuration item to be modified!")
        }</span>
        // 默认加密存储
        <span class="cov8" title="1">config.Base.SecretKey, _ = util.EncryptSecret(config.Base.SecretKey)
        config.Base.SecretID, _ = util.EncryptSecret(config.Base.SecretID)
        config.Base.SessionToken, _ = util.EncryptSecret(config.Base.SessionToken)

        // 判断config文件是否存在。不存在则创建
        home, err := homedir.Dir()
        configFile := ""
        if cfgFile != "" </span><span class="cov8" title="1">{
                if cfgFile[0] == '~' </span><span class="cov0" title="0">{
                        configFile = home + cfgFile[1:]
                }</span> else<span class="cov8" title="1"> {
                        configFile = cfgFile
                }</span>
        } else<span class="cov8" title="1"> {
                configFile = home + "/.cos.yaml"
        }</span>
        <span class="cov8" title="1">_, err = os.Stat(configFile)
        if os.IsNotExist(err) || cfgFile != "" </span><span class="cov8" title="1">{
                viper.Set("cos.base", config.Base)
                if err := viper.WriteConfigAs(configFile); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                viper.Set("cos.base", config.Base)
                if err := viper.WriteConfigAs(viper.ConfigFileUsed()); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">logger.Infoln("Modify successfully!")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package cmd

import (
        "fmt"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var configShowCmd = &amp;cobra.Command{
        Use:   "show",
        Short: "Prints information from a specified configuration file",
        Long: `Prints information from a specified configuration file

Format:
  ./coscli config show [-c &lt;config-file-path&gt;]

Example:
  ./coscli config show`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov8" title="1">{
                showConfig()
        }</span>,
}

func init() <span class="cov8" title="1">{
        configCmd.AddCommand(configShowCmd)
}</span>

func showConfig() <span class="cov8" title="1">{
        fmt.Println("Configuration file path:")
        fmt.Printf("  %s\n", viper.ConfigFileUsed())
        fmt.Println("====================")
        fmt.Println("Basic Configuration Information:")
        fmt.Printf("  Secret ID:     %s\n", config.Base.SecretID)
        fmt.Printf("  Secret Key:    %s\n", config.Base.SecretKey)
        fmt.Printf("  Session Token: %s\n", config.Base.SessionToken)
        fmt.Printf("  Mode: %s\n", config.Base.Mode)
        fmt.Printf("  CvmRoleName: %s\n", config.Base.CvmRoleName)
        fmt.Printf("  CloseAutoSwitchHost: %s\n", config.Base.CloseAutoSwitchHost)
        fmt.Println("====================")
        fmt.Println("Bucket Configuration Information:")

        for i, b := range config.Buckets </span><span class="cov8" title="1">{
                fmt.Printf("- Bucket %d :\n", i+1)
                fmt.Printf("  Name:  \t%s\n", b.Name)
                fmt.Printf("  Endpoint:\t%s\n", b.Endpoint)
                fmt.Printf("  Alias: \t%s\n", b.Alias)
                fmt.Printf("  Ofs: \t%v\n", b.Ofs)
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package cmd

import (
        "context"
        "coscli/util"
        "fmt"
        "path/filepath"
        "strings"
        "time"

        "github.com/tencentyun/cos-go-sdk-v5"

        logger "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
)

var cpCmd = &amp;cobra.Command{
        Use:   "cp",
        Short: "Upload, download or cper objects",
        Long: `Upload, download or cper objects

Format:
  ./coscli cp &lt;source_path&gt; &lt;destination_path&gt; [flags]

Example: 
  Upload:
    ./coscli cp ~/example.txt cos://examplebucket/example.txt
  Download:
    ./coscli cp cos://examplebucket/example.txt ~/example.txt
  Copy:
    ./coscli cp cos://examplebucket1/example1.txt cos://examplebucket2/example2.txt`,
        Args: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                if err := cobra.ExactArgs(2)(cmd, args); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">storageClass, _ := cmd.Flags().GetString("storage-class")
                if storageClass != "" &amp;&amp; util.IsCosPath(args[0]) </span><span class="cov8" title="1">{
                        return fmt.Errorf("--storage-class can only use in upload")
                }</span>
                <span class="cov8" title="1">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                recursive, _ := cmd.Flags().GetBool("recursive")
                include, _ := cmd.Flags().GetString("include")
                exclude, _ := cmd.Flags().GetString("exclude")
                storageClass, _ := cmd.Flags().GetString("storage-class")
                rateLimiting, _ := cmd.Flags().GetFloat32("rate-limiting")
                partSize, _ := cmd.Flags().GetInt64("part-size")
                threadNum, _ := cmd.Flags().GetInt("thread-num")
                routines, _ := cmd.Flags().GetInt("routines")
                failOutput, _ := cmd.Flags().GetBool("fail-output")
                failOutputPath, _ := cmd.Flags().GetString("fail-output-path")
                metaString, _ := cmd.Flags().GetString("meta")
                retryNum, _ := cmd.Flags().GetInt("retry-num")
                errRetryNum, _ := cmd.Flags().GetInt("err-retry-num")
                errRetryInterval, _ := cmd.Flags().GetInt("err-retry-interval")
                onlyCurrentDir, _ := cmd.Flags().GetBool("only-current-dir")
                disableAllSymlink, _ := cmd.Flags().GetBool("disable-all-symlink")
                enableSymlinkDir, _ := cmd.Flags().GetBool("enable-symlink-dir")
                disableCrc64, _ := cmd.Flags().GetBool("disable-crc64")

                meta, err := util.MetaStringToHeader(metaString)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("Copy invalid meta " + err.Error())
                }</span>

                <span class="cov8" title="1">if retryNum &lt; 0 || retryNum &gt; 10 </span><span class="cov8" title="1">{
                        return fmt.Errorf("retry-num must be between 0 and 10 (inclusive)")
                }</span>

                <span class="cov8" title="1">if errRetryNum &lt; 0 || errRetryNum &gt; 10 </span><span class="cov8" title="1">{
                        return fmt.Errorf("err-retry-num must be between 0 and 10 (inclusive)")
                }</span>

                <span class="cov8" title="1">if errRetryInterval &lt; 0 || errRetryInterval &gt; 10 </span><span class="cov8" title="1">{
                        return fmt.Errorf("err-retry-interval must be between 0 and 10 (inclusive)")
                }</span>

                <span class="cov8" title="1">srcUrl, err := util.FormatUrl(args[0])
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("format srcURL error,%v", err)
                }</span>

                <span class="cov8" title="1">destUrl, err := util.FormatUrl(args[1])
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("format destURL error,%v", err)
                }</span>

                <span class="cov8" title="1">if srcUrl.IsFileUrl() &amp;&amp; destUrl.IsFileUrl() </span><span class="cov8" title="1">{
                        return fmt.Errorf("not support cp between local directory")
                }</span>

                <span class="cov8" title="1">_, filters := util.GetFilter(include, exclude)

                fo := &amp;util.FileOperations{
                        Operation: util.Operation{
                                Recursive:         recursive,
                                Filters:           filters,
                                StorageClass:      storageClass,
                                RateLimiting:      rateLimiting,
                                PartSize:          partSize,
                                ThreadNum:         threadNum,
                                Routines:          routines,
                                FailOutput:        failOutput,
                                FailOutputPath:    failOutputPath,
                                Meta:              meta,
                                RetryNum:          retryNum,
                                ErrRetryNum:       errRetryNum,
                                ErrRetryInterval:  errRetryInterval,
                                OnlyCurrentDir:    onlyCurrentDir,
                                DisableAllSymlink: disableAllSymlink,
                                EnableSymlinkDir:  enableSymlinkDir,
                                DisableCrc64:      disableCrc64,
                        },
                        Monitor:    &amp;util.FileProcessMonitor{},
                        Config:     &amp;config,
                        Param:      &amp;param,
                        ErrOutput:  &amp;util.ErrOutput{},
                        CpType:     getCommandType(srcUrl, destUrl),
                        Command:    util.CommandCP,
                        BucketType: "COS",
                }

                if !fo.Operation.Recursive &amp;&amp; len(fo.Operation.Filters) &gt; 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("--include or --exclude only work with --recursive")
                }</span>

                <span class="cov8" title="1">startT := time.Now().UnixNano() / 1000 / 1000
                if srcUrl.IsFileUrl() &amp;&amp; destUrl.IsCosUrl() </span><span class="cov8" title="1">{
                        // 检查错误输出日志是否是本地路径的子集
                        err = util.CheckPath(srcUrl, fo, util.TypeFailOutputPath)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        // 实例化cos client
                        <span class="cov8" title="1">bucketName := destUrl.(*util.CosUrl).Bucket
                        c, err := util.NewClient(fo.Config, fo.Param, bucketName)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        // 是否关闭crc64
                        <span class="cov8" title="1">if fo.Operation.DisableCrc64 </span><span class="cov8" title="1">{
                                c.Conf.EnableCRC = false
                        }</span>
                        // 格式化上传路径
                        <span class="cov8" title="1">err = util.FormatUploadPath(srcUrl, destUrl, fo)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        // 上传
                        <span class="cov8" title="1">util.Upload(c, srcUrl, destUrl, fo)</span>
                } else<span class="cov8" title="1"> if srcUrl.IsCosUrl() &amp;&amp; destUrl.IsFileUrl() </span><span class="cov8" title="1">{
                        // 检查错误输出日志是否是本地路径的子集
                        err = util.CheckPath(destUrl, fo, util.TypeFailOutputPath)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">bucketName := srcUrl.(*util.CosUrl).Bucket
                        c, err := util.NewClient(fo.Config, fo.Param, bucketName)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        // 判断桶是否是ofs桶
                        <span class="cov8" title="1">s, err := c.Bucket.Head(context.Background())
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        // 根据s.Header判断是否是融合桶或者普通桶
                        <span class="cov8" title="1">if s.Header.Get("X-Cos-Bucket-Arch") == "OFS" </span><span class="cov8" title="1">{
                                fo.BucketType = "OFS"
                        }</span>
                        // 是否关闭crc64
                        <span class="cov8" title="1">if fo.Operation.DisableCrc64 </span><span class="cov8" title="1">{
                                c.Conf.EnableCRC = false
                        }</span>
                        // 格式化下载路径
                        <span class="cov8" title="1">err = util.FormatDownloadPath(srcUrl, destUrl, fo, c)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        // 下载
                        <span class="cov8" title="1">err = util.Download(c, srcUrl, destUrl, fo)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> if srcUrl.IsCosUrl() &amp;&amp; destUrl.IsCosUrl() </span><span class="cov8" title="1">{
                        // 实例化来源 cos client
                        srcBucketName := srcUrl.(*util.CosUrl).Bucket
                        srcClient, err := util.NewClient(fo.Config, fo.Param, srcBucketName)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        // 实例化目标 cos client
                        <span class="cov8" title="1">destBucketName := destUrl.(*util.CosUrl).Bucket
                        destClient, err := util.NewClient(fo.Config, fo.Param, destBucketName)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        // 判断桶是否是ofs桶
                        <span class="cov8" title="1">s, _ := srcClient.Bucket.Head(context.Background())
                        // 根据s.Header判断是否是融合桶或者普通桶
                        if s.Header.Get("X-Cos-Bucket-Arch") == "OFS" </span><span class="cov8" title="1">{
                                fo.BucketType = "OFS"
                        }</span>

                        // 是否关闭crc64
                        <span class="cov8" title="1">if fo.Operation.DisableCrc64 </span><span class="cov8" title="1">{
                                destClient.Conf.EnableCRC = false
                        }</span>

                        // 格式化copy路径
                        <span class="cov8" title="1">err = util.FormatCopyPath(srcUrl, destUrl, fo, srcClient)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        // 拷贝
                        <span class="cov8" title="1">err = util.CosCopy(srcClient, destClient, srcUrl, destUrl, fo)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return fmt.Errorf("cospath needs to contain %s", util.SchemePrefix)
                }</span>
                <span class="cov8" title="1">util.CloseErrorOutputFile(fo)
                endT := time.Now().UnixNano() / 1000 / 1000
                util.PrintCostTime(startT, endT)

                return nil</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(cpCmd)

        cpCmd.Flags().BoolP("recursive", "r", false, "Copy objects recursively")
        cpCmd.Flags().String("include", "", "Include files that meet the specified criteria")
        cpCmd.Flags().String("exclude", "", "Exclude files that meet the specified criteria")
        cpCmd.Flags().String("storage-class", "", "Specifying a storage class")
        cpCmd.Flags().Float32("rate-limiting", 0, "Upload or download speed limit(MB/s)")
        cpCmd.Flags().Int64("part-size", 32, "Specifies the block size(MB)")
        cpCmd.Flags().Int("thread-num", 5, "Specifies the number of partition concurrent upload or download threads")
        cpCmd.Flags().Int("routines", 3, "Specifies the number of files concurrent upload or download threads")
        cpCmd.Flags().Bool("fail-output", true, "This option determines whether the error output for failed file uploads or downloads is enabled. If enabled, the error messages for any failed file transfers will be recorded in a file within the specified directory (if not specified, the default is coscli_output). If disabled, only the number of error files will be output to the console.")
        cpCmd.Flags().String("fail-output-path", "coscli_output", "This option specifies the designated error output folder where the error messages for failed file uploads or downloads will be recorded. By providing a custom folder path, you can control the location and name of the error output folder. If this option is not set, the default error log folder (coscli_output) will be used.")
        cpCmd.Flags().String("meta", "",
                "Set the meta information of the file, "+
                        "the format is header:value#header:value, the example is Cache-Control:no-cache#Content-Encoding:gzip")
        cpCmd.Flags().Int("retry-num", 0, "Rate-limited retry. Specify 1-10 times. When multiple machines concurrently execute download operations on the same COS directory, rate-limited retry can be performed by specifying this parameter.")
        cpCmd.Flags().Int("err-retry-num", 0, "Error retry attempts. Specify 1-10 times, or 0 for no retry.")
        cpCmd.Flags().Int("err-retry-interval", 0, "Retry interval (available only when specifying error retry attempts 1-10). Specify an interval of 1-10 seconds, or if not specified or set to 0, a random interval within 1-10 seconds will be used for each retry.")
        cpCmd.Flags().Bool("only-current-dir", false, "Upload only the files in the current directory, ignoring subdirectories and their contents")
        cpCmd.Flags().Bool("disable-all-symlink", true, "Ignore all symbolic link subfiles and symbolic link subdirectories when uploading, not uploaded by default")
        cpCmd.Flags().Bool("enable-symlink-dir", false, "Upload linked subdirectories, not uploaded by default")
        cpCmd.Flags().Bool("disable-crc64", false, "Disable CRC64 data validation. By default, coscli enables CRC64 validation for data transfer")
}</span>

func cosCopy(args []string, recursive bool, include string, exclude string, meta util.Meta, storageClass string) error <span class="cov8" title="1">{
        bucketName1, cosPath1 := util.ParsePath(args[0])
        bucketName2, cosPath2 := util.ParsePath(args[1])
        c2, err := util.NewClient(&amp;config, &amp;param, bucketName2)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if recursive </span><span class="cov8" title="1">{
                c1, err := util.NewClient(&amp;config, &amp;param, bucketName1)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                // 路径分隔符
                // 记录是否是代码添加的路径分隔符
                <span class="cov8" title="1">isAddSeparator := false
                // 源路径若不以路径分隔符结尾，则添加
                if !strings.HasSuffix(cosPath1, "/") &amp;&amp; cosPath1 != "" </span><span class="cov8" title="1">{
                        isAddSeparator = true
                        cosPath1 += "/"
                }</span>
                // 判断cosDir是否是文件夹
                <span class="cov8" title="1">isDir, err := util.CheckCosPathType(c1, cosPath1, 0, &amp;util.FileOperations{})
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">if isDir </span><span class="cov8" title="1">{
                        // cosPath1是文件夹 且 cosPath2不以路径分隔符结尾，则添加
                        if cosPath2 != "" &amp;&amp; !strings.HasSuffix(cosPath2, string(filepath.Separator)) </span><span class="cov8" title="1">{
                                cosPath2 += string(filepath.Separator)
                        }</span> else<span class="cov8" title="1"> {
                                // 若cosPath2以路径分隔符结尾，且cosPath1传入时不以路径分隔符结尾，则需将cos路径的最终文件拼接至local路径最后
                                if isAddSeparator </span><span class="cov8" title="1">{
                                        fileName := filepath.Base(cosPath1)
                                        cosPath2 += fileName
                                        cosPath2 += string(filepath.Separator)
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        // cosPath1不是文件夹且路径分隔符为代码添加,则去掉路径分隔符
                        if isAddSeparator </span><span class="cov8" title="1">{
                                cosPath1 = strings.TrimSuffix(cosPath1, "/")
                        }</span>
                }
                <span class="cov8" title="1">objects, _, err := util.GetObjectsListRecursive(c1, cosPath1, 0, include, exclude)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">opt := &amp;cos.ObjectCopyOptions{
                        ObjectCopyHeaderOptions: &amp;cos.ObjectCopyHeaderOptions{
                                CacheControl:       meta.CacheControl,
                                ContentDisposition: meta.ContentDisposition,
                                ContentEncoding:    meta.ContentEncoding,
                                ContentType:        meta.ContentType,
                                Expires:            meta.Expires,
                                XCosStorageClass:   storageClass,
                                XCosMetaXXX:        meta.XCosMetaXXX,
                        },
                }

                if meta.CacheControl != "" || meta.ContentDisposition != "" || meta.ContentEncoding != "" ||
                        meta.ContentType != "" || meta.Expires != "" || meta.MetaChange </span>{<span class="cov0" title="0">
                }</span>
                <span class="cov8" title="1">{
                        opt.ObjectCopyHeaderOptions.XCosMetadataDirective = "Replaced"
                }</span>

                <span class="cov8" title="1">for _, o := range objects </span><span class="cov8" title="1">{
                        srcKey := o.Key
                        objName := srcKey[len(cosPath1):]
                        // 格式化文件名
                        dstKey := cosPath2 + objName
                        if objName == "" &amp;&amp; (strings.HasSuffix(cosPath2, "/") || cosPath2 == "") </span><span class="cov8" title="1">{
                                fileName := filepath.Base(o.Key)
                                dstKey = cosPath2 + fileName
                        }</span>

                        <span class="cov8" title="1">if dstKey == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">srcPath := fmt.Sprintf("cos://%s/%s", bucketName1, srcKey)
                        dstPath := fmt.Sprintf("cos://%s/%s", bucketName2, dstKey)
                        logger.Infoln("Copy", srcPath, "=&gt;", dstPath)

                        url, err := util.GenURL(&amp;config, &amp;param, bucketName1)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">srcURL := fmt.Sprintf("%s/%s", url.BucketURL.Host, srcKey)

                        _, _, err = c2.Object.Copy(context.Background(), dstKey, srcURL, opt)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                if len(cosPath1) == 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("Invalid srcPath")
                }</span>

                <span class="cov8" title="1">if strings.HasSuffix(cosPath1, "/") </span><span class="cov8" title="1">{
                        return fmt.Errorf("srcPath is a dir")
                }</span>

                <span class="cov8" title="1">if cosPath2 == "" || strings.HasSuffix(cosPath2, "/") </span><span class="cov8" title="1">{
                        fileName := filepath.Base(cosPath1)
                        cosPath2 = filepath.Join(cosPath2, fileName)
                        args[1] = filepath.Join(args[1], fileName)
                }</span>

                <span class="cov8" title="1">logger.Infoln("Copy", args[0], "=&gt;", args[1])
                url, err := util.GenURL(&amp;config, &amp;param, bucketName1)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">srcURL := fmt.Sprintf("%s/%s", url.BucketURL.Host, cosPath1)

                _, _, err = c2.Object.Copy(context.Background(), cosPath2, srcURL, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func getCommandType(srcUrl util.StorageUrl, destUrl util.StorageUrl) util.CpType <span class="cov8" title="1">{
        if srcUrl.IsCosUrl() </span><span class="cov8" title="1">{
                if destUrl.IsFileUrl() </span><span class="cov8" title="1">{
                        return util.CpTypeDownload
                }</span>
                <span class="cov8" title="1">return util.CpTypeCopy</span>
        }
        <span class="cov8" title="1">return util.CpTypeUpload</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cmd

import (
        "coscli/util"

        "github.com/spf13/cobra"
)

var duCmd = &amp;cobra.Command{
        Use:   "du",
        Short: "Displays the size of a bucket or objects",
        Long: `Displays the size of a bucket or objects

Format:
  ./coscli du cos://&lt;bucket_alias&gt;[/prefix/] [flags]

Example:
  ./coscli du cos://examplebucket/test/`,
        Args: cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                bucketName, cosPath := util.ParsePath(args[0])
                include, _ := cmd.Flags().GetString("include")
                exclude, _ := cmd.Flags().GetString("exclude")
                var err error
                if cosPath == "" </span><span class="cov8" title="1">{
                        err = duBucket(bucketName, include, exclude)
                }</span> else<span class="cov8" title="1"> {
                        err = duObjects(bucketName, cosPath, include, exclude)
                }</span>
                <span class="cov8" title="1">return err</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(duCmd)
        duCmd.Flags().String("include", "", "List files that meet the specified criteria")
        duCmd.Flags().String("exclude", "", "Exclude files that meet the specified criteria")
}</span>

func duBucket(bucketName string, include string, exclude string) error <span class="cov8" title="1">{
        c, err := util.NewClient(&amp;config, &amp;param, bucketName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">objects, _, err := util.GetObjectsListRecursive(c, "", 0, include, exclude)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">util.Statistic(objects)
        return nil</span>
}

func duObjects(bucketName string, cosPath string, include string, exclude string) error <span class="cov8" title="1">{
        c, err := util.NewClient(&amp;config, &amp;param, bucketName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">objects, _, err := util.GetObjectsListRecursive(c, cosPath, 0, include, exclude)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">util.Statistic(objects)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package cmd

import (
        "coscli/util"
        "fmt"
        "os"
        "strings"

        logger "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
)

var hashCmd = &amp;cobra.Command{
        Use:   "hash",
        Short: "Calculate local file's hash-code or show cos file's hash-code",
        Long: `Calculate local file's hash-code or show cos file's hash-code

Format:
  ./coscli hash &lt;file-path&gt; [--type &lt;hash-type&gt;]

Example:
  ./coscli hash cos://example --type md5`,
        Args: cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                bucketName, path := util.ParsePath(args[0])
                hashType, _ := cmd.Flags().GetString("type")
                hashType = strings.ToLower(hashType)
                var err error
                if bucketName != "" </span><span class="cov8" title="1">{
                        err = showHash(bucketName, path, hashType)
                }</span> else<span class="cov8" title="1"> {
                        _, err = calculateHash(path, hashType)
                }</span>

                <span class="cov8" title="1">return err</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(hashCmd)

        hashCmd.Flags().StringP("type", "", "crc64", "Choose the hash type(md5 or crc64)")
}</span>

func showHash(bucketName string, path string, hashType string) error <span class="cov8" title="1">{
        c, err := util.NewClient(&amp;config, &amp;param, bucketName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">switch hashType </span>{
        case "crc64":<span class="cov8" title="1">
                h, _, _, err := util.ShowHash(c, path, "crc64")
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">logger.Infoln("crc64-ecma:  ", h)</span>
        case "md5":<span class="cov8" title="1">
                h, b, _, err := util.ShowHash(c, path, "md5")
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">logger.Infoln("md5:    ", h)
                logger.Infoln("base64: ", b)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("--type can only be selected between MD5 and CRC64")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func calculateHash(path string, hashType string) (h string, err error) <span class="cov8" title="1">{
        switch hashType </span>{
        case "crc64":<span class="cov8" title="1">
                h, _, err = util.CalculateHash(path, "crc64")
                if err != nil </span><span class="cov8" title="1">{
                        return "", err
                }</span>
                <span class="cov8" title="1">logger.Infoln("crc64-ecma:  ", h)</span>
        case "md5":<span class="cov8" title="1">
                f, err := os.Stat(path)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov8" title="1">if (float64(f.Size()) / 1024 / 1024) &gt; 32 </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("MD5 of large files is not supported")
                }</span>

                <span class="cov8" title="1">hash, b, err := util.CalculateHash(path, "md5")
                if err != nil </span><span class="cov8" title="1">{
                        return "", err
                }</span>
                <span class="cov8" title="1">h = hash
                logger.Infof("md5:     %s\n", h)
                logger.Infoln("base64: ", b)</span>
        default:<span class="cov8" title="1">
                return "", fmt.Errorf("--type can only be selected between MD5 and CRC64")</span>
        }
        <span class="cov8" title="1">return h, err</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package cmd

import (
        "context"
        "coscli/util"
        "fmt"

        "github.com/spf13/cobra"
)

var lsCmd = &amp;cobra.Command{
        Use:   "ls",
        Short: "List buckets or objects",
        Long: `List buckets or objects

Format:
  ./coscli ls cos://&lt;bucket-name&gt;[/prefix/] [flags]

Example:
  ./coscli ls cos://examplebucket/test/ -r`,
        Args: cobra.MaximumNArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                limit, _ := cmd.Flags().GetInt("limit")
                recursive, _ := cmd.Flags().GetBool("recursive")
                include, _ := cmd.Flags().GetString("include")
                exclude, _ := cmd.Flags().GetString("exclude")

                if limit == 0 </span><span class="cov8" title="1">{
                        limit = 10000
                }</span> else<span class="cov8" title="1"> if limit &lt; 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("Flag --limit should be greater than 0")
                }</span>

                <span class="cov8" title="1">cosPath := ""
                if len(args) != 0 </span><span class="cov8" title="1">{
                        cosPath = args[0]
                }</span>

                <span class="cov8" title="1">cosUrl, err := util.FormatUrl(cosPath)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("cos url format error:%v", err)
                }</span>

                // 无参数，则列出当前账号下的所有存储桶
                <span class="cov8" title="1">if cosPath == "" </span><span class="cov8" title="1">{
                        // 实例化cos client
                        c, err := util.NewClient(&amp;config, &amp;param, "")
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">err = util.ListBuckets(c, limit)</span>
                } else<span class="cov8" title="1"> if cosUrl.IsCosUrl() </span><span class="cov8" title="1">{
                        // 实例化cos client
                        bucketName := cosUrl.(*util.CosUrl).Bucket
                        c, err := util.NewClient(&amp;config, &amp;param, bucketName)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">_, filters := util.GetFilter(include, exclude)
                        // 根据s.Header判断是否是融合桶或者普通桶
                        s, err := c.Bucket.Head(context.Background())
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if s.Header.Get("X-Cos-Bucket-Arch") == "OFS" </span><span class="cov8" title="1">{
                                err = util.ListOfsObjects(c, cosUrl, limit, recursive, filters)
                        }</span> else<span class="cov8" title="1"> {
                                err = util.ListObjects(c, cosUrl, limit, recursive, filters)
                        }</span>

                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                } else<span class="cov8" title="1"> {
                        return fmt.Errorf("cospath needs to contain cos://")
                }</span>
                <span class="cov8" title="1">return nil</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(lsCmd)

        lsCmd.Flags().Int("limit", 0, "Limit the number of objects listed(0~1000)")
        lsCmd.Flags().BoolP("recursive", "r", false, "List objects recursively")
        lsCmd.Flags().String("include", "", "List files that meet the specified criteria")
        lsCmd.Flags().String("exclude", "", "Exclude files that meet the specified criteria")
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package cmd

import (
        "coscli/util"
        "fmt"
        "os"

        "github.com/olekukonko/tablewriter"
        "github.com/spf13/cobra"
)

var lspartsCmd = &amp;cobra.Command{
        Use:   "lsparts",
        Short: "List multipart uploads",
        Long: `List multipart uploads

Format:
  ./coscli lsparts cos://&lt;bucket-name&gt;[/&lt;prefix&gt;] [flags]

Example:
  ./coscli lsparts cos://examplebucket/test/`,
        Args: cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                limit, _ := cmd.Flags().GetInt("limit")
                include, _ := cmd.Flags().GetString("include")
                exclude, _ := cmd.Flags().GetString("exclude")
                if limit &lt; 0 || limit &gt; 1000 </span><span class="cov8" title="1">{
                        return fmt.Errorf("Flag --limit should in range 0~1000")
                }</span>

                <span class="cov8" title="1">err := listParts(args[0], limit, include, exclude)
                return err</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(lspartsCmd)

        lspartsCmd.Flags().Int("limit", 0, "Limit the number of parts listed(0~1000)")
        lspartsCmd.Flags().String("include", "", "List files that meet the specified criteria")
        lspartsCmd.Flags().String("exclude", "", "Exclude files that meet the specified criteria")
}</span>

func listParts(arg string, limit int, include string, exclude string) error <span class="cov8" title="1">{
        bucketName, cosPath := util.ParsePath(arg)
        c, err := util.NewClient(&amp;config, &amp;param, bucketName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">uploads, err := util.GetUploadsListRecursive(c, cosPath, limit, include, exclude)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">table := tablewriter.NewWriter(os.Stdout)
        table.SetHeader([]string{"Key", "Upload ID", "Initiate time"})
        for _, u := range uploads </span><span class="cov8" title="1">{
                table.Append([]string{u.Key, u.UploadID, u.Initiated})
        }</span>
        <span class="cov8" title="1">table.SetBorder(false)
        table.SetAlignment(tablewriter.ALIGN_RIGHT)
        table.SetFooter([]string{"", "", fmt.Sprintf("Total: %d", len(uploads))})
        table.Render()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package cmd

import (
        "context"
        "coscli/util"
        "fmt"

        logger "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
        "github.com/tencentyun/cos-go-sdk-v5"
)

var mbCmd = &amp;cobra.Command{
        Use:   "mb",
        Short: "Create bucket",
        Long: `Create bucket

Format:
  ./coscli mb cos://&lt;bucket-name&gt;-&lt;appid&gt; -e &lt;endpoint&gt;

Example:
  ./coscli mb cos://examplebucket-1234567890 -e cos.ap-beijing.myqcloud.com`,
        Args: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                if err := cobra.ExactArgs(1)(cmd, args); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">bucketIDName, cosPath := util.ParsePath(args[0])
                if bucketIDName == "" || cosPath != "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("Invalid arguments! ")
                }</span>
                <span class="cov8" title="1">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                err := createBucket(cmd, args)
                return err
        }</span>,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(mbCmd)

        mbCmd.Flags().StringP("region", "r", "", "Region")
        mbCmd.Flags().BoolP("ofs", "o", false, "Ofs")
}</span>

func createBucket(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        flagRegion, _ := cmd.Flags().GetString("region")
        flagOfs, _ := cmd.Flags().GetBool("ofs")
        if param.Endpoint == "" &amp;&amp; flagRegion != "" </span><span class="cov8" title="1">{
                param.Endpoint = fmt.Sprintf("cos.%s.myqcloud.com", flagRegion)
        }</span>
        <span class="cov8" title="1">bucketIDName, _ := util.ParsePath(args[0])

        c, err := util.CreateClient(&amp;config, &amp;param, bucketIDName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">opt := &amp;cos.BucketPutOptions{
                XCosACL:                   "",
                XCosGrantRead:             "",
                XCosGrantWrite:            "",
                XCosGrantFullControl:      "",
                XCosGrantReadACP:          "",
                XCosGrantWriteACP:         "",
                CreateBucketConfiguration: nil,
        }

        if flagOfs </span><span class="cov8" title="1">{
                opt.CreateBucketConfiguration = &amp;cos.CreateBucketConfiguration{
                        BucketArchConfig: "OFS",
                }
        }</span>

        <span class="cov8" title="1">_, err = c.Bucket.Put(context.Background(), opt)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">logger.Infof("Create a new bucket! name: %s\n", bucketIDName)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package cmd

import (
        "context"
        "coscli/util"
        "encoding/xml"
        "fmt"

        logger "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
        "github.com/tencentyun/cos-go-sdk-v5"
)

var mvCmd = &amp;cobra.Command{
        Use:   "mv",
        Short: "Move objects",
        Long: `Move objects

Format:
  ./coscli mv &lt;source_path&gt; &lt;destination_path&gt; [flags]

Example: 
  Move:
    ./coscli mv ~/example.txt cos://examplebucket/example.txt`,
        Args: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                if err := cobra.ExactArgs(2)(cmd, args); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">storageClass, _ := cmd.Flags().GetString("storage-class")
                if storageClass != "" &amp;&amp; util.IsCosPath(args[0]) </span><span class="cov8" title="1">{
                        return fmt.Errorf("--storage-class can only use in upload")
                }</span>
                <span class="cov8" title="1">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                recursive, _ := cmd.Flags().GetBool("recursive")
                include, _ := cmd.Flags().GetString("include")
                exclude, _ := cmd.Flags().GetString("exclude")
                storageClass, _ := cmd.Flags().GetString("storage-class")
                metaString, _ := cmd.Flags().GetString("meta")
                meta, err := util.MetaStringToHeader(metaString)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("Move invalid meta " + err.Error())
                }</span>
                // args[0]: 源地址
                // args[1]: 目标地址
                <span class="cov8" title="1">if util.IsCosPath(args[0]) &amp;&amp; util.IsCosPath(args[1]) </span><span class="cov8" title="1">{
                        bucketIDNameSource, _ := util.ParsePath(args[0])
                        bucketIDNameDest, _ := util.ParsePath(args[1])
                        if bucketIDNameSource == bucketIDNameDest </span><span class="cov8" title="1">{
                                // 移动
                                move(args, recursive, include, exclude, meta, storageClass)
                        }</span> else<span class="cov8" title="1"> {
                                return fmt.Errorf("cospath needs the same bucket")
                        }</span>
                } else<span class="cov8" title="1"> {
                        return fmt.Errorf("cospath needs to contain cos://")
                }</span>
                <span class="cov8" title="1">return nil</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(mvCmd)

        mvCmd.Flags().BoolP("recursive", "r", false, "Move objects recursively")
        mvCmd.Flags().String("include", "", "Include files that meet the specified criteria")
        mvCmd.Flags().String("exclude", "", "Exclude files that meet the specified criteria")
        mvCmd.Flags().String("storage-class", "", "Specifying a storage class")
        mvCmd.Flags().String("meta", "",
                "Set the meta information of the file, "+
                        "the format is header:value#header:value, the example is Cache-Control:no-cache#Content-Encoding:gzip")
}</span>

func move(args []string, recursive bool, include string, exclude string, meta util.Meta, storageClass string) error <span class="cov8" title="1">{
        bucketName, cosPath1 := util.ParsePath(args[0])
        _, cosPath2 := util.ParsePath(args[1])

        c, err := util.NewClient(&amp;config, &amp;param, bucketName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">s, err := c.Bucket.Head(context.Background())
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // 根据s.Header判断是否是融合桶或者普通桶
        <span class="cov8" title="1">if s.Header.Get("X-Cos-Bucket-Arch") == "OFS" </span><span class="cov0" title="0">{
                srcPath := fmt.Sprintf("cos://%s/%s", bucketName, cosPath1)
                dstPath := fmt.Sprintf("cos://%s/%s", bucketName, cosPath2)
                logger.Infoln("Move", srcPath, "=&gt;", dstPath)

                url, err := util.GenURL(&amp;config, &amp;param, bucketName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">dstURL := fmt.Sprintf("%s/%s", url.BucketURL.Host, cosPath2)

                var closeBody bool = true

                //dstURL:tina-coscli-test-123/x
                //cosPath1:ofs
                _, err = util.PutRename(context.Background(), &amp;config, &amp;param, c, cosPath1, dstURL, closeBody)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">logger.Infof("\nAll move successfully!\n")</span>
        } else<span class="cov8" title="1"> {
                err = cosCopy(args, recursive, include, exclude, meta, storageClass)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if recursive </span><span class="cov8" title="1">{
                        err = moveObjects(args, include, exclude)
                }</span> else<span class="cov8" title="1"> {
                        err = moveObject(args)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func moveObjects(args []string, include string, exclude string) error <span class="cov8" title="1">{
        bucketName, cosDir := util.ParsePath(args[0])
        c, err := util.NewClient(&amp;config, &amp;param, bucketName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if cosDir != "" &amp;&amp; cosDir[len(cosDir)-1] != '/' </span><span class="cov8" title="1">{
                cosDir += "/"
        }</span>

        <span class="cov8" title="1">isTruncated := true
        nextMarker := ""
        deleteOrNot := false
        errorOrNot := false
        for isTruncated </span><span class="cov8" title="1">{
                objects, t, m, commonPrefixes, err := util.GetObjectsListIterator(c, cosDir, nextMarker, include, exclude)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(commonPrefixes) &gt; 0 </span><span class="cov8" title="1">{
                        files, err := getFilesAndDirs(c, cosDir, nextMarker, include, exclude)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">for _, v := range files </span><span class="cov8" title="1">{
                                err = recursivemoveObject(bucketName, v)
                                return err
                        }</span>
                        <span class="cov0" title="0">isTruncated = false</span>
                } else<span class="cov8" title="1"> {
                        isTruncated = t
                        nextMarker = m
                        var oKeys []cos.Object
                        for _, o := range objects </span><span class="cov8" title="1">{
                                oKeys = append(oKeys, cos.Object{Key: o.Key})
                        }</span>
                        <span class="cov8" title="1">if len(oKeys) &gt; 0 </span><span class="cov8" title="1">{
                                deleteOrNot = true
                        }</span>
                        <span class="cov8" title="1">opt := &amp;cos.ObjectDeleteMultiOptions{
                                XMLName: xml.Name{},
                                Quiet:   false,
                                Objects: oKeys,
                        }
                        res, _, err := c.Object.DeleteMulti(context.Background(), opt)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">for _, o := range res.DeletedObjects </span><span class="cov8" title="1">{
                                logger.Infoln("Delete ", o.Key)
                        }</span>
                        <span class="cov8" title="1">if len(res.Errors) &gt; 0 </span><span class="cov0" title="0">{
                                errorOrNot = true
                                logger.Infoln()
                                for _, e := range res.Errors </span><span class="cov0" title="0">{
                                        logger.Infoln("Fail to delete", e.Key)
                                        logger.Infoln("    Error Code: ", e.Code, " Message: ", e.Message)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if deleteOrNot == false </span><span class="cov0" title="0">{
                logger.Infoln("No objects were deleted!")
        }</span>
        <span class="cov8" title="1">if errorOrNot == false </span><span class="cov8" title="1">{
                logger.Infof("\nAll move successfully!\n")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
func moveObject(args []string) error <span class="cov8" title="1">{
        bucketName, cosPath := util.ParsePath(args[0])
        c, err := util.NewClient(&amp;config, &amp;param, bucketName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">opt := &amp;cos.ObjectDeleteOptions{
                XCosSSECustomerAglo:   "",
                XCosSSECustomerKey:    "",
                XCosSSECustomerKeyMD5: "",
                XOptionHeader:         nil,
                VersionId:             "",
        }
        _, err = c.Object.Delete(context.Background(), cosPath, opt)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">logger.Infoln("Delete", args[0], "successfully!")
        logger.Infof("\n Move successfully!\n")
        return nil</span>
}

func recursivemoveObject(bucketName string, cosPath string) error <span class="cov8" title="1">{
        c, err := util.NewClient(&amp;config, &amp;param, bucketName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">opt := &amp;cos.ObjectDeleteOptions{
                XCosSSECustomerAglo:   "",
                XCosSSECustomerKey:    "",
                XCosSSECustomerKeyMD5: "",
                XOptionHeader:         nil,
                VersionId:             "",
        }

        _, err = c.Object.Delete(context.Background(), cosPath, opt)
        return err</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package cmd

import (
        "context"
        "coscli/util"
        "fmt"

        logger "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
)

var rbCmd = &amp;cobra.Command{
        Use:   "rb",
        Short: "Remove bucket",
        Long: `Remove bucket

Format:
  ./coscli rb cos://&lt;bucket-name&gt;-&lt;app-id&gt; -e &lt;endpoint&gt;

Example:
  ./coscli rb cos://example-1234567890 -e cos.ap-beijing.myqcloud.com`,
        Args: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                if err := cobra.ExactArgs(1)(cmd, args); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">bucketIDName, cosPath := util.ParsePath(args[0])
                if bucketIDName == "" || cosPath != "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("Invalid arguments! ")
                }</span>
                <span class="cov8" title="1">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                bucketIDName, _ := util.ParsePath(args[0])
                flagRegion, _ := cmd.Flags().GetString("region")
                Force, _ := cmd.Flags().GetBool("force")
                if param.Endpoint == "" &amp;&amp; flagRegion != "" </span><span class="cov8" title="1">{
                        param.Endpoint = fmt.Sprintf("cos.%s.myqcloud.com", flagRegion)
                }</span>
                <span class="cov8" title="1">var choice string
                var err error
                if Force </span><span class="cov8" title="1">{
                        logger.Infof("Do you want to clear all inside the bucket and delete bucket %s ? (y/n)", bucketIDName)
                        _, _ = fmt.Scanf("%s\n", &amp;choice)
                        if choice == "" || choice == "y" || choice == "Y" || choice == "yes" || choice == "Yes" || choice == "YES" </span><span class="cov8" title="1">{
                                fo := &amp;util.FileOperations{
                                        Operation: util.Operation{
                                                Force: true,
                                        },
                                        Monitor:   &amp;util.FileProcessMonitor{},
                                        Config:    &amp;config,
                                        Param:     &amp;param,
                                        ErrOutput: &amp;util.ErrOutput{},
                                }
                                err = util.RemoveObjects(args, fo)
                                if err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>

                                <span class="cov8" title="1">err = abortParts(args[0], "", "")
                                if err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">err = removeBucket(bucketIDName)
                                if err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        logger.Infof("Do you want to delete %s? (y/n)", bucketIDName)
                        _, _ = fmt.Scanf("%s\n", &amp;choice)
                        if choice == "" || choice == "y" || choice == "Y" || choice == "yes" || choice == "Yes" || choice == "YES" </span><span class="cov8" title="1">{
                                err = removeBucket(bucketIDName)
                                if err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                        }
                }
                <span class="cov8" title="1">return nil</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(rbCmd)
        rbCmd.Flags().BoolP("force", "f", false, "Clear all inside the bucket and delete bucket")
        rbCmd.Flags().StringP("region", "r", "", "Region")
}</span>

func removeBucket(bucketIDName string) error <span class="cov8" title="1">{
        c, err := util.NewClient(&amp;config, &amp;param, bucketIDName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">_, err = c.Bucket.Delete(context.Background())
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">logger.Infof("Delete a empty bucket! name: %s\n", bucketIDName)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package cmd

import (
        "context"
        "encoding/xml"
        "fmt"

        "coscli/util"

        logger "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
        "github.com/tencentyun/cos-go-sdk-v5"
)

var restoreCmd = &amp;cobra.Command{
        Use:   "restore",
        Short: "Restore objects",
        Long: `Restore objects

Format:
  ./coscli restore cos://&lt;bucket-name&gt;[/&lt;prefix&gt;] [flags]

Example:
  ./coscli restore cos://examplebucket/test/ -r -d 3 -m Expedited`,
        Args: cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                recursive, _ := cmd.Flags().GetBool("recursive")
                include, _ := cmd.Flags().GetString("include")
                exclude, _ := cmd.Flags().GetString("exclude")
                days, _ := cmd.Flags().GetInt("days")
                mode, _ := cmd.Flags().GetString("mode")
                var err error
                if recursive </span><span class="cov8" title="1">{
                        err = restoreObjects(args[0], days, mode, include, exclude)
                }</span> else<span class="cov8" title="1"> {
                        err = restoreObject(args[0], days, mode)
                }</span>
                <span class="cov8" title="1">return err</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(restoreCmd)

        restoreCmd.Flags().BoolP("recursive", "r", false, "Restore objects recursively")
        restoreCmd.Flags().String("include", "", "Include files that meet the specified criteria")
        restoreCmd.Flags().String("exclude", "", "Exclude files that meet the specified criteria")
        restoreCmd.Flags().IntP("days", "d", 3, "Specifies the expiration time of temporary files")
        restoreCmd.Flags().StringP("mode", "m", "Standard", "Specifies the mode for fetching temporary files")
}</span>

func restoreObject(arg string, days int, mode string) error <span class="cov8" title="1">{
        bucketName, cosPath := util.ParsePath(arg)
        c, err := util.NewClient(&amp;config, &amp;param, bucketName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">opt := &amp;cos.ObjectRestoreOptions{
                XMLName:       xml.Name{},
                Days:          days,
                Tier:          &amp;cos.CASJobParameters{Tier: mode},
                XOptionHeader: nil,
        }

        logger.Infof("Restore cos://%s/%s\n", bucketName, cosPath)
        _, err = c.Object.PostRestore(context.Background(), cosPath, opt)
        if err != nil </span><span class="cov8" title="1">{
                logger.Errorln(err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func restoreObjects(arg string, days int, mode string, include string, exclude string) error <span class="cov8" title="1">{
        bucketName, cosPath := util.ParsePath(arg)
        c, err := util.NewClient(&amp;config, &amp;param, bucketName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">objects, _, err := util.GetObjectsListRecursive(c, cosPath, 0, include, exclude)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">succeed_num := 0
        failed_num := 0

        for _, o := range objects </span><span class="cov8" title="1">{
                err := restoreObject(fmt.Sprintf("cos://%s/%s", bucketName, o.Key), days, mode)
                if err != nil </span><span class="cov0" title="0">{
                        failed_num += 1
                }</span> else<span class="cov8" title="1"> {
                        succeed_num += 1
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package cmd

import (
        "coscli/util"
        "fmt"

        "github.com/spf13/cobra"
        "github.com/tencentyun/cos-go-sdk-v5"
)

var rmCmd = &amp;cobra.Command{
        Use:   "rm",
        Short: "Remove objects",
        Long: `Remove objects

Format:
  ./coscli rm cos://&lt;bucket-name&gt;[/prefix/] [cos://&lt;bucket-name&gt;[/prefix/]...] [flags]

Example:
  ./coscli rm cos://example/test/ -r`,
        Args: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                if err := cobra.MinimumNArgs(1)(cmd, args); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">for _, arg := range args </span><span class="cov8" title="1">{
                        bucketName, _ := util.ParsePath(arg)
                        if bucketName == "" </span><span class="cov8" title="1">{
                                return fmt.Errorf("Invalid arguments! ")
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                recursive, _ := cmd.Flags().GetBool("recursive")
                force, _ := cmd.Flags().GetBool("force")
                onlyCurrentDir, _ := cmd.Flags().GetBool("only-current-dir")
                retryNum, _ := cmd.Flags().GetInt("retry-num")
                include, _ := cmd.Flags().GetString("include")
                exclude, _ := cmd.Flags().GetString("exclude")
                failOutput, _ := cmd.Flags().GetBool("fail-output")
                failOutputPath, _ := cmd.Flags().GetString("fail-output-path")

                _, filters := util.GetFilter(include, exclude)

                fo := &amp;util.FileOperations{
                        Operation: util.Operation{
                                Recursive:      recursive,
                                Filters:        filters,
                                OnlyCurrentDir: onlyCurrentDir,
                                Force:          force,
                                RetryNum:       retryNum,
                                FailOutput:     failOutput,
                                FailOutputPath: failOutputPath,
                        },
                        Monitor:   &amp;util.FileProcessMonitor{},
                        Config:    &amp;config,
                        Param:     &amp;param,
                        ErrOutput: &amp;util.ErrOutput{},
                }
                var err error
                if recursive </span><span class="cov8" title="1">{
                        err = util.RemoveObjects(args, fo)
                }</span> else<span class="cov0" title="0"> {
                        err = util.RemoveObject(args, fo)
                }</span>
                <span class="cov8" title="1">return err</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(rmCmd)

        rmCmd.Flags().BoolP("recursive", "r", false, "Delete object recursively")
        rmCmd.Flags().BoolP("force", "f", false, "Force delete")
        rmCmd.Flags().Bool("only-current-dir", false, "Upload only the files in the current directory, ignoring subdirectories and their contents")
        rmCmd.Flags().Int("retry-num", 0, "Rate-limited retry. Specify 1-10 times. When multiple machines concurrently execute download operations on the same COS directory, rate-limited retry can be performed by specifying this parameter.")
        rmCmd.Flags().String("include", "", "List files that meet the specified criteria")
        rmCmd.Flags().String("exclude", "", "Exclude files that meet the specified criteria")
        rmCmd.Flags().Bool("fail-output", true, "This option determines whether the error output for failed file uploads or downloads is enabled. If enabled, the error messages for any failed file transfers will be recorded in a file within the specified directory (if not specified, the default is coscli_output). If disabled, only the number of error files will be output to the console.")
        rmCmd.Flags().String("fail-output-path", "coscli_output", "This option specifies the designated error output folder where the error messages for failed file uploads or downloads will be recorded. By providing a custom folder path, you can control the location and name of the error output folder. If this option is not set, the default error log folder (coscli_output) will be used.")
}</span>

// 获取所有文件和目录
func getFilesAndDirs(c *cos.Client, cosDir string, nextMarker string, include string, exclude string) (files []string, err error) <span class="cov8" title="1">{
        objects, _, _, commonPrefixes, err := util.GetObjectsListIterator(c, cosDir, nextMarker, include, exclude)
        if err != nil </span><span class="cov8" title="1">{
                return files, err
        }</span>
        <span class="cov8" title="1">tempFiles := make([]string, 0)
        tempFiles = append(tempFiles, cosDir)
        for _, v := range objects </span><span class="cov8" title="1">{
                files = append(files, v.Key)
        }</span>
        <span class="cov8" title="1">if len(commonPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                for _, v := range commonPrefixes </span><span class="cov0" title="0">{
                        subFiles, err := getFilesAndDirs(c, v, nextMarker, include, exclude)
                        if err != nil </span><span class="cov0" title="0">{
                                return files, err
                        }</span>
                        <span class="cov0" title="0">tempFiles = append(tempFiles, subFiles...)</span>
                }
        }
        <span class="cov8" title="1">files = append(files, tempFiles...)
        return files, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package cmd

import (
        clilog "coscli/logger"
        "coscli/util"
        "fmt"
        logger "github.com/sirupsen/logrus"
        "log"
        "os"
        "strings"

        homedir "github.com/mitchellh/go-homedir"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var cfgFile string
var initSkip bool
var logPath string
var config util.Config
var param util.Param
var cmdCnt int //控制某些函数在一个命令中被调用的次数

var rootCmd = &amp;cobra.Command{
        Use:   "coscli",
        Short: "Welcome to use coscli",
        Long:  "Welcome to use coscli!",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                _ = cmd.Help()
        }</span>,
        Version: util.Version,
}

func Execute() error <span class="cov0" title="0">{
        rootCmd.SilenceErrors = true
        return rootCmd.Execute()
}</span>

func init() <span class="cov8" title="1">{
        cobra.OnInitialize(initConfig)

        rootCmd.PersistentFlags().StringVarP(&amp;cfgFile, "config-path", "c", "", "config file path(default is $HOME/.cos.yaml)")
        rootCmd.PersistentFlags().StringVarP(&amp;param.SecretID, "secret-id", "i", "", "config secretId")
        rootCmd.PersistentFlags().StringVarP(&amp;param.SecretKey, "secret-key", "k", "", "config secretKey")
        rootCmd.PersistentFlags().StringVarP(&amp;param.SessionToken, "token", "", "", "config sessionToken")
        rootCmd.PersistentFlags().StringVarP(&amp;param.Endpoint, "endpoint", "e", "", "config endpoint")
        rootCmd.PersistentFlags().BoolVarP(&amp;param.Customized, "customized", "", false, "config customized")
        rootCmd.PersistentFlags().StringVarP(&amp;param.Protocol, "protocol", "p", "", "config protocol")
        rootCmd.PersistentFlags().BoolVarP(&amp;initSkip, "init-skip", "", false, "skip config init")
        rootCmd.PersistentFlags().StringVarP(&amp;logPath, "log-path", "", "", "coscli log dir")
}</span>

func initConfig() <span class="cov8" title="1">{
        // 初始化日志路径
        clilog.InitLoggerWithDir(logPath)

        home, err := homedir.Dir()
        cobra.CheckErr(err)
        viper.SetConfigType("yaml")
        firstArg := ""
        if len(os.Args) &gt; 1 </span><span class="cov8" title="1">{
                firstArg = os.Args[1]
        }</span>

        <span class="cov8" title="1">if cfgFile != "" </span><span class="cov8" title="1">{
                if cfgFile[0] == '~' </span><span class="cov0" title="0">{
                        cfgFile = home + cfgFile[1:]
                }</span>
                <span class="cov8" title="1">if !strings.HasSuffix(cfgFile, ".yaml") </span><span class="cov0" title="0">{
                        fmt.Println("config file need end with .yaml ")
                        os.Exit(1)
                }</span>
                <span class="cov8" title="1">viper.SetConfigFile(cfgFile)</span>
        } else<span class="cov8" title="1"> {
                _, err = os.Stat(home + "/.cos.yaml")
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        if firstArg != "config" </span><span class="cov0" title="0">{
                                if !initSkip </span><span class="cov0" title="0">{
                                        log.Println("Welcome to coscli!\nWhen you use coscli for the first time, you need to input some necessary information to generate the default configuration file of coscli.")
                                        initConfigFile(false)
                                        cmdCnt++
                                }</span> else<span class="cov0" title="0"> {
                                        // 若无配置文件，则需有输入ak，sk及endpoint
                                        if param.SecretID == "" </span><span class="cov0" title="0">{
                                                logger.Fatalln("missing parameter SecretID")
                                                os.Exit(1)
                                        }</span>
                                        <span class="cov0" title="0">if param.SecretKey == "" </span><span class="cov0" title="0">{
                                                logger.Fatalln("missing parameter SecretKey")
                                                os.Exit(1)
                                        }</span>
                                        <span class="cov0" title="0">if param.Endpoint == "" </span><span class="cov0" title="0">{
                                                logger.Fatalln("missing parameter Endpoint")
                                                os.Exit(1)
                                        }</span>
                                        <span class="cov0" title="0">return</span>
                                }
                        } else<span class="cov0" title="0"> {
                                if !initSkip </span><span class="cov0" title="0">{
                                        log.Println("Welcome to coscli!\nWhen you use coscli for the first time, you need to input some necessary information to generate the default configuration file of coscli.")
                                        initConfigFile(false)
                                        cmdCnt++
                                }</span> else<span class="cov0" title="0"> {
                                        return
                                }</span>
                        }

                }

                <span class="cov8" title="1">viper.AddConfigPath(home)
                viper.SetConfigName(".cos")</span>
        }

        <span class="cov8" title="1">viper.AutomaticEnv()
        if err := viper.ReadInConfig(); err == nil </span><span class="cov8" title="1">{
                if err := viper.UnmarshalKey("cos", &amp;config); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
                <span class="cov8" title="1">if config.Base.Protocol == "" </span><span class="cov0" title="0">{
                        config.Base.Protocol = "https"
                }</span>
                // 尝试解码secretId/secretKey/session, 能解开就是加密的，否则就不解
                <span class="cov8" title="1">secretKey, err := util.DecryptSecret(config.Base.SecretKey)
                if err == nil </span><span class="cov8" title="1">{
                        config.Base.SecretKey = secretKey
                }</span>
                <span class="cov8" title="1">secretId, err := util.DecryptSecret(config.Base.SecretID)
                if err == nil </span><span class="cov8" title="1">{
                        config.Base.SecretID = secretId
                }</span>
                <span class="cov8" title="1">sessionToken, err := util.DecryptSecret(config.Base.SessionToken)
                if err == nil </span><span class="cov8" title="1">{
                        config.Base.SessionToken = sessionToken
                }</span>

        } else<span class="cov0" title="0"> {
                fmt.Println(err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package cmd

import (
        "context"
        "coscli/util"
        "fmt"
        "net/http"
        "net/url"
        "time"

        logger "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
        "github.com/tencentyun/cos-go-sdk-v5"
)

var signurlCmd = &amp;cobra.Command{
        Use:   "signurl",
        Short: "Gets the signed download URL",
        Long: `Gets the signed download URL

Format:
  ./coscli signurl cos://&lt;bucket-name&gt;/&lt;key&gt; [flags]

Example:
  ./coscli signurl cos://examplebucket/test.jpg -t 100`,
        Args: cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                time, _ := cmd.Flags().GetInt("time")
                var err error
                if util.IsCosPath(args[0]) </span><span class="cov8" title="1">{
                        err = GetSignedURL(args[0], time)
                }</span> else<span class="cov8" title="1"> {
                        return fmt.Errorf("cospath needs to contain cos://")
                }</span>

                <span class="cov8" title="1">return err</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(signurlCmd)

        signurlCmd.Flags().IntP("time", "t", 10000, "Set the validity time of the signature(Default 10000)")
}</span>

func GetSignedURL(path string, t int) error <span class="cov8" title="1">{
        bucketName, cosPath := util.ParsePath(path)
        c, err := util.NewClient(&amp;config, &amp;param, bucketName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">opt := &amp;cos.PresignedURLOptions{
                Query:  &amp;url.Values{},
                Header: &amp;http.Header{},
        }
        // 格式化参数
        secretID, secretKey, secretToken := config.Base.SecretID, config.Base.SecretKey, config.Base.SessionToken
        if param.SecretID != "" </span><span class="cov8" title="1">{
                secretID = param.SecretID
                secretToken = ""
        }</span>
        <span class="cov8" title="1">if param.SecretKey != "" </span><span class="cov8" title="1">{
                secretKey = param.SecretKey
                secretToken = ""
        }</span>
        <span class="cov8" title="1">if param.SessionToken != "" </span><span class="cov8" title="1">{
                secretToken = param.SessionToken
        }</span>
        <span class="cov8" title="1">if secretToken != "" </span><span class="cov8" title="1">{
                opt.Query.Add("x-cos-security-token", secretToken)
        }</span>

        <span class="cov8" title="1">presignedURL, err := c.Object.GetPresignedURL(context.Background(), http.MethodGet, cosPath,
                secretID, secretKey, time.Second*time.Duration(t), opt)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">logger.Infoln("Signed URL:")
        logger.Infoln(presignedURL)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package cmd

import (
        "context"
        "fmt"
        "time"

        "coscli/util"

        "github.com/spf13/cobra"
)

var syncCmd = &amp;cobra.Command{
        Use:   "sync",
        Short: "Synchronize objects",
        Long: `Synchronize objects

Format:
  ./coscli sync &lt;source_path&gt; &lt;destination_path&gt; [flags]

Example:
  Sync Upload:
    ./coscli sync ~/example.txt cos://examplebucket/example.txt
  Sync Download:
    ./coscli sync cos://examplebucket/example.txt ~/example.txt
  Sync Copy:
    ./coscli sync cos://examplebucket1/example1.txt cos://examplebucket2/example2.txt`,
        Args: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                if err := cobra.ExactArgs(2)(cmd, args); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">storageClass, _ := cmd.Flags().GetString("storage-class")
                if storageClass != "" &amp;&amp; util.IsCosPath(args[0]) </span><span class="cov8" title="1">{
                        return fmt.Errorf("--storage-class can only use in upload")
                }</span>
                <span class="cov8" title="1">return nil</span>
        },
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                recursive, _ := cmd.Flags().GetBool("recursive")
                include, _ := cmd.Flags().GetString("include")
                exclude, _ := cmd.Flags().GetString("exclude")
                storageClass, _ := cmd.Flags().GetString("storage-class")
                rateLimiting, _ := cmd.Flags().GetFloat32("rate-limiting")
                partSize, _ := cmd.Flags().GetInt64("part-size")
                threadNum, _ := cmd.Flags().GetInt("thread-num")
                metaString, _ := cmd.Flags().GetString("meta")
                retryNum, _ := cmd.Flags().GetInt("retry-num")
                errRetryNum, _ := cmd.Flags().GetInt("err-retry-num")
                errRetryInterval, _ := cmd.Flags().GetInt("err-retry-interval")
                snapshotPath, _ := cmd.Flags().GetString("snapshot-path")
                delete, _ := cmd.Flags().GetBool("delete")
                routines, _ := cmd.Flags().GetInt("routines")
                failOutput, _ := cmd.Flags().GetBool("fail-output")
                failOutputPath, _ := cmd.Flags().GetString("fail-output-path")
                onlyCurrentDir, _ := cmd.Flags().GetBool("only-current-dir")
                disableAllSymlink, _ := cmd.Flags().GetBool("disable-all-symlink")
                enableSymlinkDir, _ := cmd.Flags().GetBool("enable-symlink-dir")
                disableCrc64, _ := cmd.Flags().GetBool("disable-crc64")
                backupDir, _ := cmd.Flags().GetString("backup-dir")
                force, _ := cmd.Flags().GetBool("force")

                meta, err := util.MetaStringToHeader(metaString)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("Sync invalid meta, reason: " + err.Error())
                }</span>

                <span class="cov8" title="1">if retryNum &lt; 0 || retryNum &gt; 10 </span><span class="cov8" title="1">{
                        return fmt.Errorf("retry-num must be between 0 and 10 (inclusive)")
                }</span>

                <span class="cov8" title="1">if errRetryNum &lt; 0 || errRetryNum &gt; 10 </span><span class="cov8" title="1">{
                        return fmt.Errorf("err-retry-num must be between 0 and 10 (inclusive)")
                }</span>

                <span class="cov8" title="1">if errRetryInterval &lt; 0 || errRetryInterval &gt; 10 </span><span class="cov8" title="1">{
                        return fmt.Errorf("err-retry-interval must be between 0 and 10 (inclusive)")
                }</span>

                <span class="cov8" title="1">srcUrl, err := util.FormatUrl(args[0])
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("format srcURL error,%v", err)
                }</span>

                <span class="cov8" title="1">destUrl, err := util.FormatUrl(args[1])
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("format destURL error,%v", err)
                }</span>

                <span class="cov8" title="1">if srcUrl.IsFileUrl() &amp;&amp; destUrl.IsFileUrl() </span><span class="cov8" title="1">{
                        return fmt.Errorf("not support cp between local directory")
                }</span>

                <span class="cov8" title="1">_, filters := util.GetFilter(include, exclude)

                fo := &amp;util.FileOperations{
                        Operation: util.Operation{
                                Recursive:         recursive,
                                Filters:           filters,
                                StorageClass:      storageClass,
                                RateLimiting:      rateLimiting,
                                PartSize:          partSize,
                                ThreadNum:         threadNum,
                                Routines:          routines,
                                FailOutput:        failOutput,
                                FailOutputPath:    failOutputPath,
                                Meta:              meta,
                                RetryNum:          retryNum,
                                ErrRetryNum:       errRetryNum,
                                ErrRetryInterval:  errRetryInterval,
                                OnlyCurrentDir:    onlyCurrentDir,
                                DisableAllSymlink: disableAllSymlink,
                                EnableSymlinkDir:  enableSymlinkDir,
                                DisableCrc64:      disableCrc64,
                                SnapshotPath:      snapshotPath,
                                Delete:            delete,
                                BackupDir:         backupDir,
                                Force:             force,
                        },
                        Monitor:   &amp;util.FileProcessMonitor{},
                        Config:    &amp;config,
                        Param:     &amp;param,
                        ErrOutput: &amp;util.ErrOutput{},
                        CpType:    getCommandType(srcUrl, destUrl),
                        Command:   util.CommandSync,
                }

                // 快照db实例化
                err = util.InitSnapshotDb(srcUrl, destUrl, fo)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">startT := time.Now().UnixNano() / 1000 / 1000
                if srcUrl.IsFileUrl() &amp;&amp; destUrl.IsCosUrl() </span><span class="cov8" title="1">{
                        // 检查错误输出日志是否是本地路径的子集
                        err = util.CheckPath(srcUrl, fo, util.TypeFailOutputPath)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        // 格式化上传路径
                        <span class="cov8" title="1">err = util.FormatUploadPath(srcUrl, destUrl, fo)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        // 实例化cos client
                        <span class="cov8" title="1">bucketName := destUrl.(*util.CosUrl).Bucket
                        c, err := util.NewClient(fo.Config, fo.Param, bucketName)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        // 是否关闭crc64
                        <span class="cov8" title="1">if fo.Operation.DisableCrc64 </span><span class="cov8" title="1">{
                                c.Conf.EnableCRC = false
                        }</span>
                        // 上传
                        <span class="cov8" title="1">err = util.SyncUpload(c, srcUrl, destUrl, fo)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> if srcUrl.IsCosUrl() &amp;&amp; destUrl.IsFileUrl() </span><span class="cov8" title="1">{
                        // 检查错误输出日志是否是本地路径的子集
                        err = util.CheckPath(destUrl, fo, util.TypeFailOutputPath)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if fo.Operation.Delete </span><span class="cov0" title="0">{
                                // 检查备份路径
                                err = util.CheckBackupDir(destUrl, fo)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }

                        <span class="cov8" title="1">bucketName := srcUrl.(*util.CosUrl).Bucket
                        c, err := util.NewClient(fo.Config, fo.Param, bucketName)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        // 判断桶是否是ofs桶
                        <span class="cov8" title="1">s, err := c.Bucket.Head(context.Background())
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        // 根据s.Header判断是否是融合桶或者普通桶
                        <span class="cov8" title="1">if s.Header.Get("X-Cos-Bucket-Arch") == "OFS" </span><span class="cov8" title="1">{
                                fo.BucketType = "OFS"
                        }</span>
                        // 是否关闭crc64
                        <span class="cov8" title="1">if fo.Operation.DisableCrc64 </span><span class="cov8" title="1">{
                                c.Conf.EnableCRC = false
                        }</span>
                        // 格式化下载路径
                        <span class="cov8" title="1">err = util.FormatDownloadPath(srcUrl, destUrl, fo, c)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        // 下载
                        <span class="cov8" title="1">err = util.SyncDownload(c, srcUrl, destUrl, fo)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> if srcUrl.IsCosUrl() &amp;&amp; destUrl.IsCosUrl() </span><span class="cov8" title="1">{
                        // 实例化来源 cos client
                        srcBucketName := srcUrl.(*util.CosUrl).Bucket
                        srcClient, err := util.NewClient(fo.Config, fo.Param, srcBucketName)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        // 实例化目标 cos client
                        <span class="cov8" title="1">destBucketName := destUrl.(*util.CosUrl).Bucket
                        destClient, err := util.NewClient(fo.Config, fo.Param, destBucketName)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        // 判断桶是否是ofs桶
                        <span class="cov8" title="1">s, _ := srcClient.Bucket.Head(context.Background())
                        // 根据s.Header判断是否是融合桶或者普通桶
                        if s.Header.Get("X-Cos-Bucket-Arch") == "OFS" </span><span class="cov8" title="1">{
                                fo.BucketType = "OFS"
                        }</span>

                        // 是否关闭crc64
                        <span class="cov8" title="1">if fo.Operation.DisableCrc64 </span><span class="cov8" title="1">{
                                destClient.Conf.EnableCRC = false
                        }</span>

                        // 格式化copy路径
                        <span class="cov8" title="1">err = util.FormatCopyPath(srcUrl, destUrl, fo, srcClient)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        // 拷贝
                        <span class="cov8" title="1">err = util.SyncCosCopy(srcClient, destClient, srcUrl, destUrl, fo)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return fmt.Errorf("cospath needs to contain cos://")
                }</span>
                <span class="cov8" title="1">util.CloseErrorOutputFile(fo)
                endT := time.Now().UnixNano() / 1000 / 1000
                util.PrintCostTime(startT, endT)

                return nil</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(syncCmd)

        syncCmd.Flags().BoolP("recursive", "r", false, "Synchronize objects recursively")
        syncCmd.Flags().String("include", "", "List files that meet the specified criteria")
        syncCmd.Flags().String("exclude", "", "Exclude files that meet the specified criteria")
        syncCmd.Flags().String("storage-class", "", "Specifying a storage class")
        syncCmd.Flags().Float32("rate-limiting", 0, "Upload or download speed limit(MB/s)")
        syncCmd.Flags().Int64("part-size", 32, "Specifies the block size(MB)")
        syncCmd.Flags().Int("thread-num", 5, "Specifies the number of concurrent upload or download threads")
        syncCmd.Flags().String("meta", "",
                "Set the meta information of the file, "+
                        "the format is header:value#header:value, the example is Cache-Control:no-cache#Content-Encoding:gzip")
        syncCmd.Flags().String("snapshot-path", "", "This option is used to accelerate the incremental"+
                " upload of batch files or download objects in certain scenarios."+
                " If you use the option when upload files or download objects,"+
                " coscli will generate files to record the snapshot information in the specified directory."+
                " When the next time you upload files or download objects with the option, "+
                "coscli will read the snapshot information under the specified directory for incremental upload or incremental download. "+
                "The snapshot-path you specified must be a local file system directory can be written in, "+
                "if the directory does not exist, coscli creates the files for recording snapshot information, "+
                "else coscli will read snapshot information from the path for "+
                "incremental upload(coscli will only upload the files which haven't not been successfully uploaded to oss or"+
                " been locally modified) or incremental download(coscli will only download the objects which have not"+
                " been successfully downloaded or have been modified),"+
                " and update the snapshot information to the directory. "+
                "Note: The option record the lastModifiedTime of local files "+
                "which have been successfully uploaded in local file system or lastModifiedTime of objects which have been successfully"+
                " downloaded, and compare the lastModifiedTime of local files or objects in the next cp to decided whether to"+
                " skip the file or object. "+
                "In addition, coscli does not automatically delete snapshot-path snapshot information, "+
                "in order to avoid too much snapshot information, when the snapshot information is useless, "+
                "please clean up your own snapshot-path on your own immediately.")
        syncCmd.Flags().Bool("delete", false, "Delete any other files in the specified destination path, only keeping the files synced this time. It is recommended to enable version control before using the --delete option to prevent accidental data deletion.")
        syncCmd.Flags().Int("retry-num", 0, "Rate-limited retry. Specify 1-10 times. When multiple machines concurrently execute download operations on the same COS directory, rate-limited retry can be performed by specifying this parameter.")
        syncCmd.Flags().Int("err-retry-num", 0, "Error retry attempts. Specify 1-10 times, or 0 for no retry.")
        syncCmd.Flags().Int("err-retry-interval", 0, "Retry interval (available only when specifying error retry attempts 1-10). Specify an interval of 1-10 seconds, or if not specified or set to 0, a random interval within 1-10 seconds will be used for each retry.")
        syncCmd.Flags().Int("routines", 3, "Specifies the number of files concurrent upload or download threads")
        syncCmd.Flags().Bool("fail-output", true, "This option determines whether the error output for failed file uploads or downloads is enabled. If enabled, the error messages for any failed file transfers will be recorded in a file within the specified directory (if not specified, the default is coscli_output). If disabled, only the number of error files will be output to the console.")
        syncCmd.Flags().String("fail-output-path", "coscli_output", "This option specifies the designated error output folder where the error messages for failed file uploads or downloads will be recorded. By providing a custom folder path, you can control the location and name of the error output folder. If this option is not set, the default error log folder (coscli_output) will be used.")
        syncCmd.Flags().Bool("only-current-dir", false, "Upload only the files in the current directory, ignoring subdirectories and their contents")
        syncCmd.Flags().Bool("disable-all-symlink", true, "Ignore all symbolic link subfiles and symbolic link subdirectories when uploading, not uploaded by default")
        syncCmd.Flags().Bool("enable-symlink-dir", false, "Upload linked subdirectories, not uploaded by default")
        syncCmd.Flags().Bool("disable-crc64", false, "Disable CRC64 data validation. By default, coscli enables CRC64 validation for data transfer")
        syncCmd.Flags().String("backup-dir", "", "Synchronize deleted file backups, used to save the destination-side files that have been deleted but do not exist on the source side.")
        syncCmd.Flags().Bool("force", false, "Force the operation without prompting for confirmation")
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
